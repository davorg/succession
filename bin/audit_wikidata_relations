#!/usr/bin/env perl
use v5.40;
use feature qw(try);
no warnings qw(experimental::try);
use strict;
use warnings;
use utf8;
binmode(STDOUT, ':utf8');
binmode(STDERR, ':utf8');

use Getopt::Long qw(GetOptions);
use JSON::MaybeXS ();
use DateTime ();

use lib 'lib';
use Succession::Schema;
use Succession::WikiData::Entity ();

# ----------------------------------------
# CLI options
# ----------------------------------------
my %opt = (
  apply            => 0,      # actually write fixes (guarded by --auto)
  limit            => 0,      # audit only N people
  verbose          => 0,
  sleep_ms         => 500,    # increased from 250ms to be more conservative
  max_requests     => 450,    # safety cap to avoid hitting Wikidata rate limits (0 = unlimited)
  only_with_qid    => 1,      # only audit rows that already have a QID
  fill_wikipedia   => 1,      # report MISSING_WP_LINK; fix only if enabled via --auto
  root_id          => undef,  # optional; else auto-detect sole NULL-parent row
  auto_all         => 0,      # enable all fix categories
  max_create       => 200,    # safety cap for auto-created children
  time_filter      => 1,      # only audit records with NULL or old last_audited_datetime
  audit_age_days   => 7,      # minimum days since last audit (default: 7)
);
my (@auto_opts, @ignore_opts, @only_ids);

GetOptions(
  "apply!"            => \$opt{apply},
  "limit=i"           => \$opt{limit},
  "verbose!"          => \$opt{verbose},
  "sleep-ms=i"        => \$opt{sleep_ms},
  "max-requests=i"    => \$opt{max_requests},
  "only-with-qid!"    => \$opt{only_with_qid},
  "fill-wikipedia!"   => \$opt{fill_wikipedia},
  "root-id=i"         => \$opt{root_id},
  "auto=s@"           => \@auto_opts,      # e.g. --auto MISSING_DEATH --auto PARENT_SET_UNIQUE
  "auto-all!"         => \$opt{auto_all},
  "ignore=s@"         => \@ignore_opts,    # e.g. --ignore CHILD_NOT_IN_DB --ignore "DEATH_MISMATCH,CHILD_PARENT_MISMATCH"
  "id=i@"             => \@only_ids,       # may be repeated: --id 185 --id 310
  "max-create=i"      => \$opt{max_create},
  "time-filter!"      => \$opt{time_filter},    # enable/disable time filtering
  "audit-age-days=i"  => \$opt{audit_age_days}, # minimum days since last audit
) or die "Bad options\n";

# Normalize chosen categories
my %AUTO = ();
if ($opt{auto_all}) {
  %AUTO = map { $_ => 1 } qw(
    MISSING_DEATH
    MISSING_WP_LINK
    PARENT_SET_UNIQUE
    CHILD_PARENT_SET_UNIQUE
    CHILD_CREATE_FROM_WD
    QID_REDIRECT_NORMALIZED
  );
} else {
  for my $raw (@auto_opts) {
    next unless defined $raw;
    $AUTO{ uc $_ } = 1 for grep { length } split /[, ]+/, $raw;
  }
}

my %IGNORE = ();
for my $raw (@ignore_opts) {
  next unless defined $raw;
  $IGNORE{ uc $_ } = 1 for grep { length } split /[, ]+/, $raw;
}

sub should_auto   ($code) { return $opt{apply} && !$IGNORE{uc $code} && ($opt{auto_all} || $AUTO{ uc($code) }); }
sub should_report ($code) { return !$IGNORE{ uc $code }; }

my $SLEEP = $opt{sleep_ms} / 1000.0;
sub sleep_a_bit { select(undef, undef, undef, $SLEEP) }
sub logv { return unless $opt{verbose}; print STDERR "[audit] ", @_, "\n"; }

if ((%AUTO || $opt{auto_all}) && !$opt{apply}) {
  warn "[audit] NOTE: --auto specified without --apply — running in DRY-RUN mode (no changes will be written)\n";
}

# ----------------------------------------
# Setup
# ----------------------------------------
my $schema = Succession::Schema->get_schema;

# ----------------------------------------
# DB helpers
# ----------------------------------------
sub person_by_qid ($qid) {
  return $schema->resultset('Person')->search({ 'me.wikidata_qid' => $qid })->single;
}

# YYYY-MM-DD best effort from DB value (DateTime or string)
sub db_date_ymd ($val) {
  return unless defined $val;
  return $val->ymd if ref($val) && $val->can('ymd');
  return $val if $val =~ /^\d{4}-\d{2}-\d{2}$/;
  return;
}

sub year_from_db_date ($val) {
  my $ymd = db_date_ymd($val) // return;
  return $1 if $ymd =~ /^(\d{4})-/;
  return;
}

# Choose unique DB parent for a child (using child's WD parent_qids)
sub choose_unique_parent_for_child_entity ($child_wd) {
  my @p_qids = $child_wd->parent_qids;
  my %seen; @p_qids = grep { $_ && !$seen{$_}++ } @p_qids;
  my @ids;
  for my $q (@p_qids) {
    if (my $row = person_by_qid($q)) { push @ids, $row->id }
  }
  return ($ids[0], "unique") if @ids == 1;
  return (undef, @ids == 0 ? "none" : "ambiguous");
}

# Create a minimal child (uses Person->add_child if available)
sub create_child_stub_with_parent ($parent_id, $child_wd) {

  my $parent = $schema->resultset('Person')->find($parent_id) or return;

  my $attrs = {
    born          => $child_wd->birth_date // '1000-01-01',   # NOT NULL guard
    died          => $child_wd->death_date,
    sex           => ($child_wd->sex // 'm'),
    wikipedia     => $child_wd->enwiki_url,
    wikidata_qid  => $child_wd->qid,
  };
  my $label = $child_wd->label_en // $child_wd->qid;

  if ($parent->can('add_child')) {
    # If your add_child supports a title param, pass it; otherwise it can ignore.
    return $parent->add_child({ %$attrs, title => $label });
  }

  # Fallback
  my $row = $schema->resultset('Person')->create({ %$attrs, parent => $parent_id });
  $row->make_slug();
  $row->add_to_titles({ title => $label, is_default => 1 });
  return $row;
}

# CSV helper for quoted English label
sub label_q ($wd) {
  my $l = $wd->label_en // "";
  $l =~ s/"/""/g;
  return qq{"$l"};
}

# ----------------------------------------
# Root detection (exactly one NULL parent)
# ----------------------------------------
my $root_id;
if (defined $opt{root_id}) {
  $root_id = $opt{root_id};
} else {
  my @null_parents = $schema->resultset('Person')
    ->search({ 'me.parent' => undef }, { columns => [qw/me.id/] })
    ->get_column('id')->all;
  if (@null_parents == 1) {
    $root_id = $null_parents[0];
  } else {
    # If user targets specific --id, allow continuing without a single-root invariant
    if (!@only_ids) {
      die "Expected exactly one NULL-parent root; found ".scalar(@null_parents).". Use --root-id or fix data.\n";
    }
  }
}
logv "Root person id: ".(defined $root_id ? $root_id : '(not enforced for --id)');

# ----------------------------------------
# Result set (prefetch parent; respect --id; skip root unless explicitly targeted)
# ----------------------------------------
my %where;
if (@only_ids) {
  $where{'me.id'} = { -in => \@only_ids };
} else {
  $where{'me.id'} = { '!=' => $root_id } if defined $root_id;
}
$where{'me.wikidata_qid'} = { '!=' => undef } if $opt{only_with_qid};

# Add time filtering to only audit records with NULL or old last_audited_datetime
if ($opt{time_filter}) {
  my $cutoff_date = DateTime->now->subtract(days => $opt{audit_age_days});
  my $dtf = $schema->storage->datetime_parser;
  my $cutoff_str = $dtf->format_datetime($cutoff_date);
  
  $where{'-or'} = [
    { 'me.last_audited_datetime' => undef },
    { 'me.last_audited_datetime' => { '<' => $cutoff_str } },
  ];
  
  logv "Time filter enabled: only auditing records with NULL or last_audited_datetime < $cutoff_str";
}

my $rs = $schema->resultset('Person')->search(
  \%where,
  {
    prefetch => 'parent',
    columns  => [qw/me.id me.born me.died me.wikidata_qid me.wikipedia me.parent me.sex/],
  }
);

# ----------------------------------------
# CSV heading
# ----------------------------------------
print ($opt{apply} ? "" : "DRY RUN — no changes will be written\n");
print join(",", qw(kind person_id qid note detail expected current)) . "\n";

my $reported = 0;
sub report {
  my ($code, @fields) = @_;
  return unless should_report($code);
  print join(",", $code, @fields), "\n";
  $reported++;
}

# Track parents that need a reorder after edits
my %needs_reorder;  # parent_id => 1

# Track Wikidata API requests to avoid rate limiting
my $wikidata_requests = 0;
sub check_request_limit {
  return 0 if $opt{max_requests} == 0;  # 0 means unlimited
  if ($wikidata_requests >= $opt{max_requests}) {
    warn "[audit] Reached maximum request limit ($opt{max_requests}). Stopping to avoid rate limiting.\n";
    warn "[audit] Total requests made: $wikidata_requests\n";
    warn "[audit] To continue, use --max-requests with a higher value or 0 for unlimited.\n";
    return 1;  # signal to stop
  }
  return 0;  # continue
}
sub increment_request_count { $wikidata_requests++ }
sub get_request_count { return $wikidata_requests }

# ----------------------------------------
# Main loop
# ----------------------------------------
my $n = 0;
my $created = 0;

PERSON: while (my $p = $rs->next) {
  last if $opt{limit} && $n >= $opt{limit};
  $n++;

  my $pid   = $p->id;
  my $qid   = $p->wikidata_qid or next;
  my $born  = db_date_ymd($p->born);
  my $died  = $p->died ? db_date_ymd($p->died) : undef;

  sleep_a_bit();

  # Check if we're approaching the rate limit before making a request
  if (check_request_limit()) {
    last PERSON;  # exit the main loop
  }

  # Build WD entity (follows redirects) — built-in try/catch (statement form)
  my $wd;
  try {
    increment_request_count();  # count the request before making it
    $wd = Succession::WikiData::Entity::from_qid($qid);
  }
  catch ($e) {
    # Check for rate limiting error
    if ($e =~ /RATE_LIMIT:/) {
      warn "[audit] $e\n";
      warn "[audit] Wikidata rate limit hit after $wikidata_requests requests. Exiting immediately.\n";
      warn "[audit] Use --max-requests to set a lower limit, or --sleep-ms to slow down requests.\n";
      last PERSON;  # exit the main loop
    }
    warn "[audit] fetch failed for $qid: $e";
    undef $wd;
  }
  next unless $wd;

  # Redirect normalization
  if (defined $wd->redirected_from && $wd->qid ne $qid) {
    report("QID_REDIRECT_NORMALIZED", $pid, $qid, label_q($wd), $wd->qid, "", "");
    if (should_auto('QID_REDIRECT_NORMALIZED')) {
      $p->update({ wikidata_qid => $wd->qid });
      $qid = $wd->qid;
    }
  }

  # Visibility: P40 with P1039 (non-bio kinship on parent)
  for my $cq ( $wd->child_qids_nonbio ) {
    report("CHILD_P40_NONBIO", $pid, $qid, label_q($wd), $cq, "P1039 present", "");
  }

  # Death checks
  if (my $wd_death = $wd->death_date) {
    if (!$died) {
      report("MISSING_DEATH", $pid, $qid, label_q($wd), $wd_death, "", "");
      if (should_auto('MISSING_DEATH')) {
        $p->update({ died => $wd_death });
      }
    } else {
      my $db_y = year_from_db_date($died);
      my ($wd_y) = ($wd_death =~ /^(\d{4})/);
      if (defined $db_y && defined $wd_y && $db_y != $wd_y) {
        report("DEATH_MISMATCH", $pid, $qid, label_q($wd), $wd_y, $db_y, "");
        if (should_auto('DEATH_MISMATCH')) {
          $p->update({ died => $wd_death });
        }
      }
    }
  }

  # Wikipedia backfill
  if ($opt{fill_wikipedia} && (!defined $p->wikipedia || $p->wikipedia eq '')) {
    if (my $wp = $wd->enwiki_url) {
      report("MISSING_WP_LINK", $pid, $qid, label_q($wd), $wp, "", "");
      if (should_auto('MISSING_WP_LINK')) {
        $p->update({ wikipedia => $wp });
      }
    }
  }

  # Parent checks (either P22 or P25)
  my $skip_parent_checks = (defined $root_id && $pid == $root_id && !@only_ids) ? 1 : 0;
  if (!$skip_parent_checks) {
    my @parent_qids = $wd->parent_qids;
    my %seen_q; @parent_qids = grep { $_ && !$seen_q{$_}++ } @parent_qids;

    my @parent_rows = map { person_by_qid($_) } @parent_qids;
    my @parent_ids  = map { $_ ? $_->id : () } @parent_rows;

    my $current_parent_row = $p->parent;                    # related object or undef
    my $current_parent_id  = $current_parent_row ? $current_parent_row->id + 0 : undef;

    if (defined $current_parent_id) {
      my $ok = scalar grep { $_ == $current_parent_id } @parent_ids;
      if (!$ok) {
        report("PARENT_NOT_WD",
          $pid, $qid, label_q($wd),
          (join("|", @parent_qids)),
          (join("|", @parent_ids)),
          $current_parent_id
        );
      }
    } else {
      if (@parent_ids == 1) {
        my $chosen_id = $parent_ids[0];
        report("PARENT_SET_UNIQUE", $pid, $qid, label_q($wd),
          (join("|", @parent_qids)), $chosen_id, "");
        if (should_auto('PARENT_SET_UNIQUE')) {
          $p->update({ parent => $chosen_id });
          $needs_reorder{$chosen_id} = 1;
        }
      } elsif (@parent_ids == 0) {
        report("PARENT_NOT_IN_DB", $pid, $qid, label_q($wd),
          (join("|", @parent_qids)), "", "");
      } else {
        report("PARENT_AMBIGUOUS_BOTH_IN_DB", $pid, $qid, label_q($wd),
          (join("|", @parent_qids)), (join("|", @parent_ids)), "");
      }
    }
  }

  # Children (strict biology): parent-side filter (P1039) + child-side verification (P22/P25)
  my @child_qids = $wd->child_qids_biological;

  CHILD: for my $cq (@child_qids) {
    sleep_a_bit();

    # Check if we're approaching the rate limit before making a request
    if (check_request_limit()) {
      last PERSON;  # exit both loops
    }

    my $child_wd;
    try {
      increment_request_count();  # count the request before making it
      $child_wd = Succession::WikiData::Entity::from_qid($cq);
    }
    catch ($e) {
      # Check for rate limiting error
      if ($e =~ /RATE_LIMIT:/) {
        warn "[audit] $e\n";
        warn "[audit] Wikidata rate limit hit after $wikidata_requests requests. Exiting immediately.\n";
        warn "[audit] Use --max-requests to set a lower limit, or --sleep-ms to slow down requests.\n";
        last PERSON;  # exit both loops
      }
      warn "[audit] fetch child failed for $cq: $e";
      undef $child_wd;
    }
    next CHILD unless $child_wd;

    # Guard: audited person must be one of child's WD parents
    my %cp = map { $_ => 1 } $child_wd->parent_qids;
    if (!$cp{$qid}) {
      report("CHILD_OF_OTHER_PARENTS", $pid, $qid, label_q($wd), $child_wd->qid,
             join("|", sort keys %cp), "");
      next CHILD;
    }

    my $child_person = person_by_qid($child_wd->qid);
    if (!$child_person) {
      report("CHILD_NOT_IN_DB", $pid, $qid, label_q($wd), $child_wd->qid, "", "");

      if (should_auto('CHILD_CREATE_FROM_WD') && $created < $opt{max_create}) {
        my ($parent_id, $why) = choose_unique_parent_for_child_entity($child_wd);
        if (defined $parent_id) {
          my $new = create_child_stub_with_parent($parent_id, $child_wd);
          if ($new) {
            $created++;
            report("CHILD_CREATED_UNIQUE",
              $new->id, $child_wd->qid, "(child created)",
              $parent_id, ($new->wikipedia // ""), ($new->slug // ""));
            $needs_reorder{$parent_id} = 1;
          }
        } else {
          my @ids = map { my $r = person_by_qid($_); $r ? $r->id : () } $child_wd->parent_qids;
          my $detail = join("|", @ids);
          my $code = ($why && $why eq 'ambiguous') ? "CHILD_CREATE_AMBIGUOUS" : "CHILD_CREATE_NO_PARENTS";
          report($code, $pid, $qid, label_q($wd), $child_wd->qid, $detail, "");
        }
      }
      next CHILD;
    }

    # Child exists → parent pointer checks
    my $cid = $child_person->id;
    my $child_parent_row = $child_person->parent;
    my $cp_id  = $child_parent_row ? $child_parent_row->id + 0 : undef;

    if (!defined $cp_id) {
      report("CHILD_PARENT_MISSING", $pid, $qid, label_q($wd), $cid, "", "");
      if (should_auto('CHILD_PARENT_SET_UNIQUE')) {
        my @cpar_ids = map { my $r = person_by_qid($_); $r ? $r->id : () } $child_wd->parent_qids;
        if (@cpar_ids == 1) {
          $child_person->update({ parent => $cpar_ids[0] });
          report("CHILD_PARENT_SET_UNIQUE", $cid, $child_wd->qid, "(child)",
                 (join("|", $child_wd->parent_qids)), $cpar_ids[0], "");
          $needs_reorder{$cpar_ids[0]} = 1;
        }
      }
      next CHILD;
    }

    # If already attached to THIS audited person, OK
    next CHILD if $cp_id == $pid;

    # If attached to the other WD parent, OK
    my %wd_parent_ids = map { my $r = person_by_qid($_); $r ? ($r->id => 1) : () } $child_wd->parent_qids;
    if (%wd_parent_ids && $wd_parent_ids{$cp_id}) {
      next CHILD;
    }

    # Heuristic fallback: opposite-sex parent in DB → treat as OK
    my $p_sex  = $p->sex;
    my $cp_sex = $child_parent_row ? $child_parent_row->sex : undef;
    if (defined $p_sex && defined $cp_sex && $p_sex ne $cp_sex) {
      next CHILD;
    }

    report("CHILD_PARENT_MISMATCH", $pid, $qid, label_q($wd), $cid, $cp_id, $pid);
  }
  
  # Update last_audited_datetime for this person
  if ($opt{apply}) {
    my $now = DateTime->now;
    my $dtf = $schema->storage->datetime_parser;
    my $now_str = $dtf->format_datetime($now);
    $p->update({ last_audited_datetime => $now_str });
    logv "Updated last_audited_datetime for person $pid to $now_str";
  }
}

# ----------------------------------------
# Batched family reorders (once per affected parent)
# ----------------------------------------
if ($opt{apply}) {
  for my $parent_id (keys %needs_reorder) {
    my $parent = $schema->resultset('Person')->find($parent_id);
    next unless $parent;
    $parent->reorder_family;
  }
}

warn sprintf "Audited %d person(s), reported %d issue(s)%s\n",
  $n, $reported, ($opt{apply} ? " (apply on; fixes limited to chosen --auto categories)" : "");
warn sprintf "Total Wikidata API requests: %d%s\n",
  $wikidata_requests,
  ($opt{max_requests} > 0 ? " (limit: $opt{max_requests})" : " (unlimited)");

__END__

=head1 NAME

audit_wikidata_relations - Audit and synchronize person records with Wikidata

=head1 SYNOPSIS

  # Dry-run audit of all people with Wikidata QIDs
  bin/audit_wikidata_relations

  # Audit with verbose output
  bin/audit_wikidata_relations --verbose

  # Auto-fix missing death dates (dry-run)
  bin/audit_wikidata_relations --auto MISSING_DEATH

  # Auto-fix missing death dates (apply changes)
  bin/audit_wikidata_relations --auto MISSING_DEATH --apply

  # Auto-fix all supported error types
  bin/audit_wikidata_relations --auto-all --apply

  # Audit specific people by ID
  bin/audit_wikidata_relations --id 185 --id 310

  # Audit first 10 people only
  bin/audit_wikidata_relations --limit 10

  # Ignore certain error types
  bin/audit_wikidata_relations --ignore CHILD_NOT_IN_DB,DEATH_MISMATCH

=head1 DESCRIPTION

This program audits person records in the database against their corresponding
Wikidata entities (identified by wikidata_qid). It checks for:

=over 4

=item * QID redirects

=item * Missing or mismatched death dates

=item * Missing Wikipedia links

=item * Parent-child relationships (both directions)

=item * Children not yet in the database

=back

The program outputs a CSV report of all issues found. With C<--auto> and C<--apply>,
it can automatically fix certain types of errors.

By default, the program runs in DRY-RUN mode (no changes are written). Use
C<--apply> to actually write changes to the database.

=head1 OPTIONS

=head2 Core Options

=over 4

=item B<--apply>

Actually write changes to the database. Without this flag, the program runs in
DRY-RUN mode and only reports what it would do.

=item B<--verbose>

Enable verbose logging to STDERR. Useful for debugging and understanding what
the program is doing.

=item B<--limit=N>

Audit only the first N people. Useful for testing.

=item B<--id=N>

Audit only specific person IDs. Can be repeated multiple times:
C<--id 185 --id 310>

=back

=head2 Auto-Fix Options

=over 4

=item B<--auto=ERROR_TYPE>

Enable automatic fixes for specific error types. Can be repeated or use
comma-separated values: C<--auto MISSING_DEATH --auto PARENT_SET_UNIQUE>
or C<--auto MISSING_DEATH,PARENT_SET_UNIQUE>

See L</"AUTO-FIX CAPABILITIES"> for supported error types.

=item B<--auto-all>

Enable automatic fixes for all supported error types. Equivalent to:
C<--auto MISSING_DEATH,MISSING_WP_LINK,PARENT_SET_UNIQUE,CHILD_PARENT_SET_UNIQUE,CHILD_CREATE_FROM_WD,QID_REDIRECT_NORMALIZED>

=back

=head2 Filter Options

=over 4

=item B<--ignore=ERROR_TYPE>

Suppress reporting of specific error types. Can be repeated or use
comma-separated values: C<--ignore CHILD_NOT_IN_DB,DEATH_MISMATCH>

=item B<--only-with-qid> / B<--no-only-with-qid>

Only audit people who have a wikidata_qid (default: enabled). Use
C<--no-only-with-qid> to audit all people.

=item B<--fill-wikipedia> / B<--no-fill-wikipedia>

Report missing Wikipedia links (default: enabled). Use C<--no-fill-wikipedia>
to skip this check.

=item B<--time-filter> / B<--no-time-filter>

Enable or disable time filtering for audit records (default: enabled). When enabled,
only audits person records that have either:

=over 4

=item * NULL C<last_audited_datetime> (never audited before), OR

=item * C<last_audited_datetime> older than C<--audit-age-days> (default: 7 days)

=back

Use C<--no-time-filter> to audit all records regardless of when they were last audited.
This is useful for forcing a complete audit of the database.

=item B<--audit-age-days=N>

Minimum number of days since last audit before a record is eligible for auditing again
(default: 7). Only used when C<--time-filter> is enabled. For example:

=over 4

=item * C<--audit-age-days 7> - audit records older than 7 days (default)

=item * C<--audit-age-days 1> - audit records older than 1 day

=item * C<--audit-age-days 30> - audit records older than 30 days

=back

=back

=head2 Advanced Options

=over 4

=item B<--root-id=N>

Explicitly specify the root person ID. By default, the program auto-detects
the person with no parent (NULL parent). Use this if you have multiple roots
or want to specify a different root.

=item B<--sleep-ms=N>

Milliseconds to sleep between Wikidata API calls (default: 500, previously 250).
Increase this if you're hitting rate limits. Higher values = slower execution but
less risk of rate limiting.

=item B<--max-requests=N>

Maximum number of Wikidata API requests to make before stopping (default: 450).
This is a safety limit to prevent hitting Wikidata's rate limits. Set to 0 for
unlimited requests (use with caution and monitor for 429 errors). When the limit
is reached, the program stops gracefully.

If you encounter HTTP 429 (Too Many Requests) errors, try:
- Lowering C<--max-requests> (e.g., 300 or 200)
- Increasing C<--sleep-ms> (e.g., 1000 for 1 second between requests)
- Running the audit in smaller batches using C<--limit>

=item B<--max-create=N>

Maximum number of children to auto-create when using
C<--auto CHILD_CREATE_FROM_WD> (default: 200). Safety cap to prevent
accidentally creating too many records.

=back

=head1 ERROR TYPES

The program reports various types of errors/issues in CSV format. Each row
contains: error_code, person_id, qid, note, detail, expected, current

=head2 QID Issues

=over 4

=item B<QID_REDIRECT_NORMALIZED>

The person's wikidata_qid points to a redirected entity. Wikidata returns
the canonical QID.

B<Auto-fix:> Updates the wikidata_qid to the canonical value.

=back

=head2 Death Date Issues

=over 4

=item B<MISSING_DEATH>

Wikidata has a death date but the database record has NULL.

B<Auto-fix:> Populates the died field from Wikidata.

=item B<DEATH_MISMATCH>

The death year in the database differs from Wikidata's death year.

B<Auto-fix:> Updates the died field to match Wikidata.

B<Manual fix:> Review both sources and determine which is correct. If the
database is correct, you may need to update Wikidata or ignore this error.

=back

=head2 Wikipedia Link Issues

=over 4

=item B<MISSING_WP_LINK>

The person has no Wikipedia link in the database, but Wikidata has an English
Wikipedia article (sitelink).

B<Auto-fix:> Populates the wikipedia field from Wikidata.

=back

=head2 Parent Issues

=over 4

=item B<PARENT_NOT_WD>

The person's parent in the database doesn't match any of the parents listed
in Wikidata (P22 father or P25 mother).

B<Manual fix:> Review the relationship. Either update Wikidata, update the
database, or investigate if the database is tracking a different lineage
(e.g., legal vs. biological parent).

=item B<PARENT_SET_UNIQUE>

The person has no parent in the database, but Wikidata lists exactly one
parent who exists in the database.

B<Auto-fix:> Sets the parent field to the unique matching parent.

=item B<PARENT_NOT_IN_DB>

The person has no parent in the database, and none of their Wikidata parents
are in the database.

B<Manual fix:> Add the parent(s) to the database first, then re-run the audit.

=item B<PARENT_AMBIGUOUS_BOTH_IN_DB>

The person has no parent in the database, but both Wikidata parents are in
the database, making the choice ambiguous.

B<Manual fix:> Manually determine which parent should be used based on your
data model (e.g., prefer father for patrilineal succession). Update the parent
field directly in the database.

=back

=head2 Child Issues

=over 4

=item B<CHILD_P40_NONBIO>

Wikidata lists a child (P40) but also marks the relationship as non-biological
(P1039 present). These are reported but not considered errors.

B<Manual action:> Review if this relationship should be tracked in your database.

=item B<CHILD_OF_OTHER_PARENTS>

A Wikidata child (P40) claims parents that don't include this person. This
indicates an inconsistency in Wikidata where P40 on the parent doesn't match
P22/P25 on the child.

B<Manual fix:> Review Wikidata and fix the inconsistency there, or ignore if
known to be correct (e.g., step-parent relationships).

=item B<CHILD_NOT_IN_DB>

Wikidata lists a biological child (P40 without P1039) who isn't in the database.

B<Auto-fix:> If the child has exactly one parent in the database, creates a
minimal person record with basic info from Wikidata. Limited by C<--max-create>
(default 200).

B<Manual fix:> If auto-fix can't handle it (ambiguous parents, no parents),
manually add the child using other tools or scripts.

=item B<CHILD_CREATED_UNIQUE>

Confirmation that a child was auto-created from Wikidata.

=item B<CHILD_CREATE_AMBIGUOUS>

Can't auto-create child because both parents are in the database (ambiguous
which to use as parent).

B<Manual fix:> Manually create the child with the appropriate parent.

=item B<CHILD_CREATE_NO_PARENTS>

Can't auto-create child because no parents are in the database.

B<Manual fix:> Add parent(s) first, then re-run the audit.

=item B<CHILD_PARENT_MISSING>

A child exists in the database but has no parent set.

B<Auto-fix:> If the child's Wikidata entity has exactly one parent in the
database, sets the parent field.

B<Manual fix:> If ambiguous, manually set the parent.

=item B<CHILD_PARENT_SET_UNIQUE>

Confirmation that a child's parent was auto-set.

=item B<CHILD_PARENT_MISMATCH>

A child's parent in the database doesn't match expected relationships based
on Wikidata. The child is attached to a different person than would be expected.

B<Manual fix:> Review the relationships and determine if the database parent
is correct, or if it should be updated. This could indicate a data modeling
choice (e.g., adoptive vs. biological parent).

=back

=head1 AUTO-FIX CAPABILITIES

The following error types can be automatically fixed with C<--auto>:

=over 4

=item B<MISSING_DEATH>

Copies death date from Wikidata to the database.

=item B<MISSING_WP_LINK>

Copies Wikipedia URL from Wikidata to the database.

=item B<PARENT_SET_UNIQUE>

Sets parent when exactly one Wikidata parent is in the database.

=item B<CHILD_PARENT_SET_UNIQUE>

Sets a child's parent when exactly one Wikidata parent is in the database.

=item B<CHILD_CREATE_FROM_WD>

Creates minimal child records from Wikidata when they have a unique parent
in the database. Limited by C<--max-create> (default 200).

=item B<QID_REDIRECT_NORMALIZED>

Updates QID to canonical value when Wikidata redirects.

=back

Note: All auto-fixes require C<--apply> to actually write changes. Without
C<--apply>, the program runs in DRY-RUN mode and only reports what would
be done.

=head1 EXAMPLES

=head2 Basic Auditing

  # See all issues (dry-run, no changes)
  bin/audit_wikidata_relations

  # Save report to a file
  bin/audit_wikidata_relations > audit_report.csv

  # Audit with details about API calls
  bin/audit_wikidata_relations --verbose

=head2 Fixing Specific Issues

  # Fix missing death dates (dry-run first)
  bin/audit_wikidata_relations --auto MISSING_DEATH

  # If results look good, apply changes
  bin/audit_wikidata_relations --auto MISSING_DEATH --apply

  # Fix multiple types
  bin/audit_wikidata_relations --auto MISSING_DEATH --auto MISSING_WP_LINK --apply

  # Or use comma-separated list
  bin/audit_wikidata_relations --auto MISSING_DEATH,MISSING_WP_LINK --apply

=head2 Comprehensive Fixes

  # Fix everything possible (dry-run first!)
  bin/audit_wikidata_relations --auto-all

  # Review output, then apply if safe
  bin/audit_wikidata_relations --auto-all --apply

=head2 Targeted Audits

  # Audit specific people
  bin/audit_wikidata_relations --id 185 --id 310

  # Test on first 10 people
  bin/audit_wikidata_relations --limit 10

  # Ignore certain errors you're not concerned about
  bin/audit_wikidata_relations --ignore CHILD_NOT_IN_DB,DEATH_MISMATCH

=head2 Creating Children from Wikidata

  # Find children not in database
  bin/audit_wikidata_relations | grep CHILD_NOT_IN_DB

  # Auto-create children with unique parents (dry-run)
  bin/audit_wikidata_relations --auto CHILD_CREATE_FROM_WD

  # Apply if safe (creates up to 200 by default)
  bin/audit_wikidata_relations --auto CHILD_CREATE_FROM_WD --apply

  # Increase limit if needed
  bin/audit_wikidata_relations --auto CHILD_CREATE_FROM_WD --apply --max-create 500

=head2 Workflow for Data Maintenance

  # 1. Run full audit to see all issues
  bin/audit_wikidata_relations > audit_$(date +%Y%m%d).csv

  # 2. Fix safe/obvious issues automatically
  bin/audit_wikidata_relations --auto MISSING_DEATH,MISSING_WP_LINK,QID_REDIRECT_NORMALIZED --apply

  # 3. Review remaining issues and fix manually or with targeted auto-fixes
  bin/audit_wikidata_relations --auto PARENT_SET_UNIQUE --apply

  # 4. Handle ambiguous cases manually based on your data model

=head1 OUTPUT FORMAT

The program outputs CSV with the following columns:

=over 4

=item 1. B<kind> - Error code (e.g., MISSING_DEATH, PARENT_NOT_WD)

=item 2. B<person_id> - Database ID of the person

=item 3. B<qid> - Wikidata QID

=item 4. B<note> - Quoted English label from Wikidata, or descriptive text

=item 5. B<detail> - Additional context (varies by error type)

=item 6. B<expected> - Expected value (if applicable)

=item 7. B<current> - Current value (if applicable)

=back

=head1 NOTES

=over 4

=item * B<Audit Tracking>: The program tracks when each person record was last audited
using the C<last_audited_datetime> field:

=over 4

=item - On each audit run (with C<--apply>), the C<last_audited_datetime> is updated

=item - By default (C<--time-filter>), only records with NULL or old C<last_audited_datetime> are audited

=item - This allows the audit to run incrementally over multiple days without re-auditing recent records

=item - Use C<--no-time-filter> to force auditing all records regardless of last audit time

=item - Adjust C<--audit-age-days> to control how often records should be re-audited (default: 7 days)

=back

For example, with default settings and a database of 2000 people where each run audits
~450 people (due to rate limiting):

=over 4

=item - Day 1: Audit 450 people (25% of database)

=item - Day 2: Audit next 450 people (another 25%)

=item - Day 3: Audit next 450 people (another 25%)

=item - Day 4-5: Audit remaining people (25%)

=item - Days 6-7: No records eligible (all audited within 7 days)

=item - Day 8: Day 1 records become eligible again (7+ days old)

=back

=item * B<Rate Limiting Protection>: The program includes safeguards to prevent
hitting Wikidata's rate limits:

=over 4

=item - Default sleep time of 500ms between requests (configurable via C<--sleep-ms>)

=item - Default maximum of 450 requests per run (configurable via C<--max-requests>)

=item - Immediate exit on HTTP 429 (Too Many Requests) errors

=item - Request counter displayed at the end of execution

=back

If you need to audit the entire database, run the program in batches using C<--limit>
or process specific people with C<--id>.

=item * The program respects C<--sleep-ms> between Wikidata API calls. The default
has been increased to 500ms (from 250ms) to be more conservative and avoid rate
limiting.

=item * Auto-created children get minimal data (birth/death dates, sex, Wikipedia
link, QID). You may need to add titles and other details manually.

=item * The program automatically triggers C<reorder_family> on parents after
making changes that affect child ordering.

=item * Some errors (like PARENT_AMBIGUOUS_BOTH_IN_DB) require manual judgment
based on your data model and cannot be auto-fixed.

=item * Always run in dry-run mode first (without C<--apply>) to review what
would be changed before applying fixes.

=back

=head1 SEE ALSO

=over 4

=item * L<Succession::WikiData::Entity> - Module that fetches Wikidata entities

=item * L<Succession::Schema> - Database schema

=item * Wikidata properties used: P22 (father), P25 (mother), P40 (child), P1039 (kinship to subject)

=back

=head1 AUTHOR

Dave Cross

=cut

